import os
import tempfile
from pathlib import Path

import streamlit as st

# Import your working backend
from royalty_mvp import (
    analyze_package,
    compute_cross_stream_diagnostics,
    generate_executive_docx,
    generate_master_package_docx,
    write_report_json,
)

st.set_page_config(page_title="Royalty Intelligence", layout="wide")

st.title("Royalty Intelligence")
st.caption("Upload a royalty statement package to generate diagnostic reports.")

uploaded = st.file_uploader(
    "Upload statements package",
    type=["zip", "xlsx", "xls", "csv", "tsv", "txt"]
)

if st.button("Run Diagnostic"):
    if not uploaded:
        st.error("Please upload a file first.")
        st.stop()

    # Save upload temporarily so your existing pipeline can read by file path
    suffix = Path(uploaded.name).suffix or ".zip"
    with tempfile.NamedTemporaryFile(delete=False, suffix=suffix) as tmp:
        tmp.write(uploaded.getbuffer())
        input_path = tmp.name

    try:
        st.info("Running analysis...")

        # Run full package analysis
        package_report = analyze_package(input_path)

        # Ensure cross-stream diagnostics exist
        cross_stream = package_report.get("cross_stream_diagnostics") or compute_cross_stream_diagnostics(package_report)
        package_report["cross_stream_diagnostics"] = cross_stream

        # Attach package context to units (so unit docs reference package intelligence)
        unit_reports = package_report.get("unit_reports", []) or []
        package_coverage = package_report.get("package_coverage", {}) or {}

        for r in unit_reports:
            r["package_context"] = {
                "package_coverage": package_coverage,
                "cross_stream_diagnostics": cross_stream,
            }

        # Generate master DOCX
        master_docx = generate_master_package_docx(package_report)

        # Generate unit DOCX files
        unit_doc_paths = []
        for r in unit_reports:
            docx_filename = generate_executive_docx(r)
            unit_doc_paths.append(docx_filename)

        # Save JSON temporarily
        json_path = "royalty_intelligence_report.json"
        write_report_json(package_report, json_path)

        st.success("Diagnostic complete.")

        # -------------------------
        # Downloads
        # -------------------------

        st.subheader("Download Reports")

        # Master report
        with open(master_docx, "rb") as f:
            st.download_button(
                label="Download Master Package Report",
                data=f,
                file_name=Path(master_docx).name,
                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            )

        # Unit reports
        if unit_doc_paths:
            st.subheader("Unit Reports")
            for p in unit_doc_paths:
                with open(p, "rb") as f:
                    st.download_button(
                        label=f"Download {Path(p).name}",
                        data=f,
                        file_name=Path(p).name,
                        mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    )

        # JSON
        with open(json_path, "rb") as f:
            st.download_button(
                label="Download JSON Report",
                data=f,
                file_name=json_path,
                mime="application/json",
            )

        # -------------------------
        # Small On-Screen Summary
        # -------------------------

        st.subheader("Quick Summary")

        rollup = package_report.get("workbook_rollup", {}) or {}
        st.write("Units analyzed:", rollup.get("unit_count", 0))
        st.write("Coverage present:", package_coverage.get("families_present", {}))
        st.write("Missing coverage:", package_coverage.get("missing_families", []))

        signals = (cross_stream.get("signals") or [])[:3]
        if signals:
            st.write("Top Signals:")
            for s in signals:
                st.write("â€¢", s.get("summary"))

    except Exception as e:
        st.error(f"{type(e).__name__}: {e}")

    finally:
        try:
            os.remove(input_path)
        except Exception:
            pass


import os
import tempfile
from pathlib import Path

import streamlit as st

# Import your working functions from royalty_mvp.py
from royalty_mvp import (
    analyze_package,
    compute_cross_stream_diagnostics,
    generate_executive_docx,
    generate_master_package_docx,
    write_report_json,
)

st.set_page_config(page_title="Royalty Intelligence MVP", layout="wide")

st.title("Royalty Intelligence â€” MVP Demo")
st.caption("Upload a royalty statement package (.zip/.xlsx/.csv). Generates a master package report + unit reports + JSON.")

uploaded = st.file_uploader("Upload statements package", type=["zip", "xlsx", "xls", "csv", "tsv", "txt"])

outdir = st.text_input("Output folder", value="reports")
verbose = st.checkbox("Verbose logs", value=False)

run = st.button("Run Diagnostic")

if run:
    if not uploaded:
        st.error("Please upload a file first.")
        st.stop()

    # Ensure output folder exists
    out_path = Path(outdir)
    out_path.mkdir(parents=True, exist_ok=True)

    # Save upload to a temp file so your existing pipeline can read it by path
    suffix = Path(uploaded.name).suffix or ".zip"
    with tempfile.NamedTemporaryFile(delete=False, suffix=suffix) as tmp:
        tmp.write(uploaded.getbuffer())
        input_path = tmp.name

    try:
        st.write("Running analysis...")
        package_report = analyze_package(input_path, verbose=verbose)

        # Ensure cross-stream diagnostics exist
        cross_stream = package_report.get("cross_stream_diagnostics") or compute_cross_stream_diagnostics(package_report)
        package_report["cross_stream_diagnostics"] = cross_stream

        # Attach package_context to units so per-unit DOCX includes package intelligence
        unit_reports = package_report.get("unit_reports", []) or []
        package_coverage = package_report.get("package_coverage", {}) or {}

        for r in unit_reports:
            r["package_context"] = {
                "package_coverage": package_coverage,
                "cross_stream_diagnostics": cross_stream,
            }

        # Generate unit docs
        unit_doc_paths = []
        for r in unit_reports:
            docx_filename = generate_executive_docx(r)
            p = Path(docx_filename)
            final = out_path / p.name
            try:
                p.replace(final)
                unit_doc_paths.append(str(final))
            except Exception:
                unit_doc_paths.append(str(p))

        # Generate master doc
        master_docx = generate_master_package_docx(package_report)
        mp = Path(master_docx)
        master_final = out_path / mp.name
        try:
            mp.replace(master_final)
            master_docx = str(master_final)
        except Exception:
            master_docx = str(mp)

        # Save JSON
        json_path = out_path / "royalty_intelligence_report.json"
        write_report_json(package_report, str(json_path))

        # UI Outputs
        st.success("Done.")
        st.subheader("Downloads")

        # Master doc download
        with open(master_docx, "rb") as f:
            st.download_button(
                label="Download Master Package Report (DOCX)",
                data=f,
                file_name=Path(master_docx).name,
                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            )

        # JSON download
        with open(json_path, "rb") as f:
            st.download_button(
                label="Download JSON Report",
                data=f,
                file_name=json_path.name,
                mime="application/json",
            )

        # Unit doc downloads
        if unit_doc_paths:
            st.subheader("Unit Reports")
            for p in unit_doc_paths:
                with open(p, "rb") as f:
                    st.download_button(
                        label=f"Download {Path(p).name}",
                        data=f,
                        file_name=Path(p).name,
                        mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    )

        # Small preview panel
        st.subheader("Quick Summary")
        rollup = package_report.get("workbook_rollup", {}) or {}
        st.write(f"Units analyzed: {rollup.get('unit_count', 0)}")
        st.write("Coverage present:", package_report.get("package_coverage", {}).get("families_present", {}))
        st.write("Missing coverage:", package_report.get("package_coverage", {}).get("missing_families", []))
        st.write("Top signals:", [s.get("summary") for s in (cross_stream.get("signals") or [])[:3]])

    except Exception as e:
        st.error(f"Error: {type(e).__name__}: {e}")
    finally:
        # Clean temp upload file
        try:
            os.remove(input_path)
        except Exception:
            pass
